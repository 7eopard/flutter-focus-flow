> Read this in English: [Developer Handover (DEVELOPER_HANDOVER.md)](./DEVELOPER_HANDOVER.md)

# 开发者交接文档：Pomodoro 生产力中心

本文档是为开发者准备的实践指南。其主要目标是解释代码库背后的**核心架构决策**，因为理解这些对于维护应用质量和有效扩展至关重要。

> 关于从最终用户的角度了解应用功能，请参阅 **[用户手册 (README.zh-hans.md)](./README.zh-hans.md)**。理解功能如何呈现给用户是开发工作的重要背景。

## 1. 核心架构决策与基本原理

本节解释了关键技术选择背后的*原因*。

### 决策 1：逻辑的严格解耦（Hooks 模式）
-   **目标：** 创建一个可维护、可测试，并且能抵御由复杂状态交互引起的错误的 codebase。
-   **采用方法：** 使用自定义 Hooks 实现严格的关注点分离。`App.tsx` 组件作为高级装配器，而不是业务逻辑的容器。
    -   `useTimer`: 这是应用的“引擎”。它被故意设计成“无知的”，只关心时间、模式和间隔。
    -   `useInteractions`: 这是“控制器”或“中间件”。其唯一目的是将混乱的用户输入（旋钮拖动、长按、点击、滚动）转换为对 `useTimer` 的清晰指令。这种分离是应用中**最关键的架构模式**。
-   **原因：** 这防止了一种常见的失败模式，即微小的UI更改意外地破坏了核心逻辑。它还使得在没有浏览器环境的情况下更容易对 `useTimer` 进行单元测试。

### 决策 2：高保真、高性能的 UI（SVG 与高级 CSS）
-   **目标：** 渲染一个视觉上复杂且动画流畅的计时器表盘，使其感觉像一个物理对象，并在所有设备上都具有健壮的响应式能力。
-   **采用方法：** 混合方法。计时器表盘使用SVG以获得图形保真度，而其布局则由一个复杂的多层CSS架构管理。
-   **SVG 分层系统 (`src/components/timer/layers/`)**: 为了在没有 `z-index` 的情况下管理堆叠顺序，我们在 `TimerView.tsx` 中创建了一个声明式的、基于组件的分层系统。
-   **“画中画”响应式架构 (CSS)**: 为了确保数字时间显示*绝不*会溢出其圆形容器，我们在 `index.css` 中使用了三部分系统：`vmin` 用于主尺寸定义，一个绝对定位的“安全区”容器，以及 `cqw` 单位用于在该安全区内按比例缩放内容。任何修改计时器布局的开发者都必须首先理解这个架构。

### 决策 3：零延迟的动态音频（程序化生成）
-   **目标：** 提供即时的音频反馈和非重复的音景，而不产生预录制音频文件的延迟或体积问题。
-   **采用方法：** 所有声音都通过 `useAudio.ts` 中的 Web Audio API 实时生成。
-   **原因：** 声音合成的复杂性是为了满足产品对“自然”声音和即时UI反馈的需求，这是一个必要的权衡。

### 决策 4：在单一组件内实现自包含的UI状态
-   **目标：** 在不污染全局状态或使现有现代UI组件复杂化的情况下，添加一个完全不同的UI范式（即“老式手机模式”）。
-   **采用方法：** 整个“老式手机模式”被实现为 `App.tsx` 中 `LegacyPhoneView` 组件内的一个自包含的“微应用”。它所有独特的状态（如设置视图vs计时器视图，输入的本地显示值）、渲染逻辑（基于文本的进度条）和样式（原生无样式按钮，内联样式）都被封装在这个单一组件中。
-   **原因：** 这种方法展示了**高内聚和低耦合**。它将老式手机模式视为一个功能完整、隔离的模块。这防止了其特殊需求（如原生按钮渲染或独特的状态处理）迫使我们对结构良好的现代UI进行过早或不必要的重构。这是一个务实的选择，它允许两种截然不同的用户体验哲学在同一个代码库中干净地共存。

---

## 2. 代码库结构

-   `src/hooks/`: **应用的“大脑”。** 存放解耦的逻辑。
-   `src/components/`: **应用的UI。**
    -   `timer/layers/`: 现代UI的SVG分层系统的实现。
-   `src/App.tsx`: 主装配器，也包含了自包含的 `LegacyPhoneView` 组件。
-   `index.css`: **关键布局逻辑。** 包含现代计时器的复杂响应式架构。

## 3. 常见任务指南

### 如何添加新设置（现代UI）
1.  **定义类型：** 在 `src/types.ts` 中添加新设置。
2.  **添加UI：** 在 `src/components/SettingsView.tsx` 中创建UI控件。
3.  **更新Hook：** 在 `src/hooks/useSettings.ts` 中添加默认值和 `localStorage` 逻辑。

### 如何调试交互错误（现代UI）
-   现代UI的所有交互逻辑都集中在 `src/hooks/useInteractions.ts` 中。在此文件的事件处理程序中设置断点。

### 如何修改老式手机UI
-   老式手机模式的所有逻辑和渲染都唯一地位于 `App.tsx` 的 `LegacyPhoneView` 组件中。在此处的更改不会影响现代UI。

---
## 5. 设计演进：任务状态模型

本节记录了为应用的任务管理系统引入一个更复杂、更强大的状态模型的设计过程。其目标是从一个简单的“待办/完成”列表，演进为一个能够反映任务阻塞和优先级的动态系统。

### 5.1. 初始需求

为处理中的任务增加更细致的状态，包括：
-   `waiting others` (等待他人)
-   `delayed` (延期/搁置)
-   `postponed` (推迟)

### 5.2. 核心分析：区分“状态”与“动作”

在设计阶段，一个关键的区分被提出：
-   **状态 (State):** `waiting` 和 `delayed` 描述了任务当前“被阻塞”的客观事实。
-   **动作 (Action):** `postponed` 描述了一个用户“推迟”任务的动作。这个动作的结果是为任务分配一个新的未来日期，使其逻辑上回归到“待办 (Todo)”状态。

这一区分避免了不必要地增加顶层状态，保持了核心模型的简洁性。

### 5.3. 模型设计：“主状态 + 子状态”与“推迟”标记

基于上述分析，最终确定了以下模型：
1.  **主状态 (Primary Status):** 核心状态模型被精简并扩展为：`todo` (待办), `doing` (进行中), `suspended` (已暂停), `done` (已完成)。`suspended` 状态完美地涵盖了所有“被阻塞”的场景。
2.  **暂停原因 (Suspension Reason):** 为 `suspended` 状态的任务增加了一个可选的 `suspensionReason` 字段，其值为 `waiting` 或 `delayed`。这清晰地将“为什么暂停”作为了“已暂停”状态的一个属性，而非一个全新的主状态。
3.  **“推迟”标记 (Postponed Flag):** 为了保留“这个任务曾被评估过”的重要上下文，我们为任务增加了一个 `isPostponed` 布尔标记。当一个已有日期的任务被用户延后到更晚的日期时，此标记被设为 `true`。

### 5.4. “优先队列”排序模型

为了将任务的紧迫性动态地反映在UI中，我们设计了一个“优先队列”模型，该模型根据规则自动对任务进行分组和排序，而非依赖于固定的状态。
1.  **`Outstanding` (今日待办/紧急):** 这是一个*动态计算*的最高优先级分组，位于列表顶端。它包含所有状态为 `doing` 的任务，以及那些已逾期、今日截止或今日开始的任务。
2.  **`Pending` (已暂停):** 紧随其后的是所有 `status` 为 `suspended` 的任务。
3.  **`Upcoming` (未来待办):** 包含所有 `status` 为 `todo` 的任务。
    - 在这个分组内部，`isPostponed` 为 `true` 的任务会获得更高的排序优先级，以体现其“被重新承诺过”的上下文。
4.  **`Done` (已完成):** 位于列表底部。

这个分层的、动态的排序系统，使得应用能够智能地将最相关的任务自动呈现在用户面前，将管理负担降至最低。

---

## 6. 架构决策：层级化与关联化的任务模型

-   **目标：** 在不牺牲性能或造成复杂状态管理的前提下，实现子任务、依赖关系和归档功能。
-   **采用方法：**
    1.  **数据模型扩展 (`src/types.ts`):** 扩展 `Task` 接口，增加了 `parentTaskId`（用于建立树状的父子关系）、`prerequisiteTaskIds`（用于建立一个有向无环图(DAG)的依赖关系），以及一个新的 `'archived'` 状态。
    2.  **逻辑集中化 (`useTasks.ts`):** 所有的复杂逻辑——包括级联删除/归档、父子状态同步、依赖解锁——都严格限定在 `useTasks` 这一个Hook中。这维持了我们核心的关注点分离原则，防止业务逻辑泄露到UI层。
    3.  **递归UI渲染 (`TaskItem.tsx`):** 为了显示任务树，`TaskItem` 组件被设计为可递归的。它会为其每个子任务渲染一个新的 `TaskItem` 实例。这种模式优雅地处理了任意深度的嵌套，并使每个任务项的状态（如是否展开）能被独立管理。
-   **给维护者的关键逻辑点：**
    -   **级联操作:** 删除或归档一个父任务会影响其所有后代。
    -   **状态同步:** 子任务的完成可能触发父任务的完成；父任务的完成会强制完成其所有子任务。
    -   **依赖引擎:** 依赖解锁逻辑位于 `toggleTask` 函数中。每当一个任务完成时，会进行一次全局检查，看是否有其他任务的所有前置条件因此被满足。这是一个**响应式**系统，而非主动调度系统。